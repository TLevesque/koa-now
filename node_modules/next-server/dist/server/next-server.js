"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable import/first, no-return-await */
const path_1 = require("path");
const url_1 = require("url");
const querystring_1 = require("querystring");
const fs_1 = __importDefault(require("fs"));
const render_1 = require("./render");
const router_1 = __importStar(require("./router"));
const utils_1 = require("./utils");
const next_config_1 = __importDefault(require("next-server/next-config"));
const constants_1 = require("next-server/constants");
const asset = __importStar(require("../lib/asset"));
const envConfig = __importStar(require("../lib/runtime-config"));
const utils_2 = require("../lib/utils");
class Server {
    constructor({ dir = '.', staticMarkup = false, quiet = false, conf = null } = {}) {
        this.dir = path_1.resolve(dir);
        this.quiet = quiet;
        const phase = this.currentPhase();
        this.nextConfig = next_config_1.default(phase, this.dir, conf);
        this.distDir = path_1.join(this.dir, this.nextConfig.distDir);
        // Only serverRuntimeConfig needs the default
        // publicRuntimeConfig gets it's default in client/index.js
        const { serverRuntimeConfig = {}, publicRuntimeConfig, assetPrefix, generateEtags } = this.nextConfig;
        this.buildId = this.readBuildId();
        this.renderOpts = {
            staticMarkup,
            distDir: this.distDir,
            buildId: this.buildId,
            generateEtags
        };
        // Only the `publicRuntimeConfig` key is exposed to the client side
        // It'll be rendered as part of __NEXT_DATA__ on the client side
        if (publicRuntimeConfig) {
            this.renderOpts.runtimeConfig = publicRuntimeConfig;
        }
        // Initialize next/config with the environment configuration
        envConfig.setConfig({
            serverRuntimeConfig,
            publicRuntimeConfig
        });
        const routes = this.generateRoutes();
        this.router = new router_1.default(routes);
        this.setAssetPrefix(assetPrefix);
    }
    currentPhase() {
        return constants_1.PHASE_PRODUCTION_SERVER;
    }
    handleRequest(req, res, parsedUrl) {
        // Parse url if parsedUrl not provided
        if (!parsedUrl || typeof parsedUrl !== 'object') {
            parsedUrl = url_1.parse(req.url, true);
        }
        // Parse the querystring ourselves if the user doesn't handle querystring parsing
        if (typeof parsedUrl.query === 'string') {
            parsedUrl.query = querystring_1.parse(parsedUrl.query);
        }
        res.statusCode = 200;
        return this.run(req, res, parsedUrl)
            .catch((err) => {
            if (!this.quiet)
                console.error(err);
            res.statusCode = 500;
            res.end('Internal Server Error');
        });
    }
    getRequestHandler() {
        return this.handleRequest.bind(this);
    }
    setAssetPrefix(prefix) {
        this.renderOpts.assetPrefix = prefix ? prefix.replace(/\/$/, '') : '';
        asset.setAssetPrefix(this.renderOpts.assetPrefix);
    }
    // Backwards compatibility
    async prepare() { }
    // Backwards compatibility
    async close() { }
    setImmutableAssetCacheControl(res) {
        res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
    generateRoutes() {
        const routes = [
            {
                match: router_1.route('/_next/static/:path*'),
                fn: async (req, res, params) => {
                    // The commons folder holds commonschunk files
                    // The chunks folder holds dynamic entries
                    // The buildId folder holds pages and potentially other assets. As buildId changes per build it can be long-term cached.
                    if (params.path[0] === constants_1.CLIENT_STATIC_FILES_RUNTIME || params.path[0] === 'chunks' || params.path[0] === this.buildId) {
                        this.setImmutableAssetCacheControl(res);
                    }
                    const p = path_1.join(this.distDir, constants_1.CLIENT_STATIC_FILES_PATH, ...(params.path || []));
                    await this.serveStatic(req, res, p);
                }
            },
            {
                match: router_1.route('/_next/:path*'),
                // This path is needed because `render()` does a check for `/_next` and the calls the routing again
                fn: async (req, res, params, parsedUrl) => {
                    await this.render404(req, res, parsedUrl);
                }
            },
            {
                // It's very important to keep this route's param optional.
                // (but it should support as many params as needed, separated by '/')
                // Otherwise this will lead to a pretty simple DOS attack.
                // See more: https://github.com/zeit/next.js/issues/2617
                match: router_1.route('/static/:path*'),
                fn: async (req, res, params) => {
                    const p = path_1.join(this.dir, 'static', ...(params.path || []));
                    await this.serveStatic(req, res, p);
                }
            }
        ];
        if (this.nextConfig.useFileSystemPublicRoutes) {
            // It's very important to keep this route's param optional.
            // (but it should support as many params as needed, separated by '/')
            // Otherwise this will lead to a pretty simple DOS attack.
            // See more: https://github.com/zeit/next.js/issues/2617
            routes.push({
                match: router_1.route('/:path*'),
                fn: async (req, res, params, parsedUrl) => {
                    const { pathname, query } = parsedUrl;
                    await this.render(req, res, pathname, query, parsedUrl);
                }
            });
        }
        return routes;
    }
    async run(req, res, parsedUrl) {
        try {
            const fn = this.router.match(req, res, parsedUrl);
            if (fn) {
                await fn();
                return;
            }
        }
        catch (err) {
            if (err.code === 'DECODE_FAILED') {
                res.statusCode = 400;
                return this.renderError(null, req, res, '/_error', {});
            }
            throw err;
        }
        if (req.method === 'GET' || req.method === 'HEAD') {
            await this.render404(req, res, parsedUrl);
        }
        else {
            res.statusCode = 501;
            res.end('Not Implemented');
        }
    }
    async render(req, res, pathname, query, parsedUrl) {
        if (utils_1.isInternalUrl(req.url)) {
            return this.handleRequest(req, res, parsedUrl);
        }
        if (utils_1.isBlockedPage(pathname)) {
            return await this.render404(req, res, parsedUrl);
        }
        const html = await this.renderToHTML(req, res, pathname, query);
        if (utils_2.isResSent(res)) {
            return;
        }
        if (this.nextConfig.poweredByHeader) {
            res.setHeader('X-Powered-By', 'Next.js ' + "7.0.2-canary.34");
        }
        return render_1.sendHTML(req, res, html, req.method, this.renderOpts);
    }
    async renderToHTML(req, res, pathname, query) {
        try {
            return await render_1.renderToHTML(req, res, pathname, query, this.renderOpts);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                res.statusCode = 404;
                return this.renderErrorToHTML(null, req, res, pathname, query);
            }
            else {
                if (!this.quiet)
                    console.error(err);
                res.statusCode = 500;
                return this.renderErrorToHTML(err, req, res, pathname, query);
            }
        }
    }
    async renderError(err, req, res, pathname, query) {
        res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');
        const html = await this.renderErrorToHTML(err, req, res, pathname, query);
        return render_1.sendHTML(req, res, html, req.method, this.renderOpts);
    }
    async renderErrorToHTML(err, req, res, pathname, query) {
        return render_1.renderErrorToHTML(err, req, res, pathname, query, this.renderOpts);
    }
    async render404(req, res, parsedUrl = url_1.parse(req.url, true)) {
        const { pathname, query } = parsedUrl;
        res.statusCode = 404;
        return this.renderError(null, req, res, pathname, query);
    }
    async serveStatic(req, res, path) {
        if (!this.isServeableUrl(path)) {
            return this.render404(req, res);
        }
        try {
            return await render_1.serveStatic(req, res, path);
        }
        catch (err) {
            if (err.code === 'ENOENT' || err.statusCode === 404) {
                this.render404(req, res);
            }
            else {
                throw err;
            }
        }
    }
    isServeableUrl(path) {
        const resolved = path_1.resolve(path);
        if (resolved.indexOf(path_1.join(this.distDir) + path_1.sep) !== 0 &&
            resolved.indexOf(path_1.join(this.dir, 'static') + path_1.sep) !== 0) {
            // Seems like the user is trying to traverse the filesystem.
            return false;
        }
        return true;
    }
    readBuildId() {
        if (!fs_1.default.existsSync(path_1.resolve(this.distDir, constants_1.BUILD_ID_FILE))) {
            throw new Error(`Could not find a valid build in the '${this.distDir}' directory! Try building your app with 'next build' before starting the server.`);
        }
        return fs_1.default.readFileSync(path_1.join(this.distDir, constants_1.BUILD_ID_FILE), 'utf8').trim();
    }
}
exports.default = Server;
