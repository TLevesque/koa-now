"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const react_1 = __importDefault(require("react"));
const server_1 = require("react-dom/server");
const send_1 = __importDefault(require("send"));
const etag_1 = __importDefault(require("etag"));
const fresh_1 = __importDefault(require("fresh"));
const require_1 = __importStar(require("./require"));
const router_1 = __importDefault(require("../lib/router/router"));
const utils_1 = require("../lib/utils");
const head_1 = __importStar(require("../lib/head"));
const loadable_1 = __importDefault(require("../lib/loadable"));
const loadable_capture_1 = __importDefault(require("../lib/loadable-capture"));
const constants_1 = require("next-server/constants");
// Based on https://github.com/jamiebuilds/react-loadable/pull/132
function getDynamicImportBundles(manifest, moduleIds) {
    return moduleIds.reduce((bundles, moduleId) => {
        if (typeof manifest[moduleId] === 'undefined') {
            return bundles;
        }
        return bundles.concat(manifest[moduleId]);
    }, []);
}
// since send doesn't support wasm yet
send_1.default.mime.define({ 'application/wasm': ['wasm'] });
async function render(req, res, pathname, query, opts) {
    const html = await renderToHTML(req, res, pathname, query, opts);
    sendHTML(req, res, html, req.method, opts);
}
exports.render = render;
function renderToHTML(req, res, pathname, query, opts) {
    return doRender(req, res, pathname, query, opts);
}
exports.renderToHTML = renderToHTML;
async function renderError(err, req, res, pathname, query, opts) {
    const html = await renderErrorToHTML(err, req, res, query, opts);
    sendHTML(req, res, html, req.method, opts);
}
exports.renderError = renderError;
function renderErrorToHTML(err, req, res, pathname, query, opts = {}) {
    return doRender(req, res, pathname, query, Object.assign({}, opts, { err, page: '/_error' }));
}
exports.renderErrorToHTML = renderErrorToHTML;
function getPageFiles(buildManifest, page) {
    const normalizedPage = require_1.normalizePagePath(page);
    const files = buildManifest.pages[normalizedPage];
    if (!files) {
        console.warn(`Could not find files for ${normalizedPage} in .next/build-manifest.json`);
        return [];
    }
    return files;
}
async function doRender(req, res, pathname, query, { err, page, buildId, assetPrefix, runtimeConfig, distDir, dir, dev = false, staticMarkup = false, nextExport } = {}) {
    page = page || pathname;
    const documentPath = path_1.join(distDir, constants_1.SERVER_DIRECTORY, constants_1.CLIENT_STATIC_FILES_PATH, buildId, 'pages', '_document');
    const appPath = path_1.join(distDir, constants_1.SERVER_DIRECTORY, constants_1.CLIENT_STATIC_FILES_PATH, buildId, 'pages', '_app');
    let [buildManifest, reactLoadableManifest, Component, Document, App] = await Promise.all([
        require(path_1.join(distDir, constants_1.BUILD_MANIFEST)),
        require(path_1.join(distDir, constants_1.REACT_LOADABLE_MANIFEST)),
        require_1.default(page, { distDir }),
        require(documentPath),
        require(appPath)
    ]);
    Component = Component.default || Component;
    if (typeof Component !== 'function') {
        throw new Error(`The default export is not a React Component in page: "${page}"`);
    }
    App = App.default || App;
    Document = Document.default || Document;
    const asPath = req.url;
    const ctx = { err, req, res, pathname: page, query, asPath };
    const router = new router_1.default(page, query, asPath);
    const props = await utils_1.loadGetInitialProps(App, { Component, router, ctx });
    const devFiles = buildManifest.devFiles;
    const files = [
        ...new Set([
            ...getPageFiles(buildManifest, page),
            ...getPageFiles(buildManifest, '/_app'),
            ...getPageFiles(buildManifest, '/_error')
        ])
    ];
    // the response might be finshed on the getinitialprops call
    if (utils_1.isResSent(res))
        return;
    let reactLoadableModules = [];
    const renderPage = (options = Page => Page) => {
        let EnhancedApp = App;
        let EnhancedComponent = Component;
        // For backwards compatibility
        if (typeof options === 'function') {
            EnhancedComponent = options(Component);
        }
        else if (typeof options === 'object') {
            if (options.enhanceApp) {
                EnhancedApp = options.enhanceApp(App);
            }
            if (options.enhanceComponent) {
                EnhancedComponent = options.enhanceComponent(Component);
            }
        }
        const app = react_1.default.createElement(loadable_capture_1.default, { report: moduleName => reactLoadableModules.push(moduleName) },
            react_1.default.createElement(EnhancedApp, Object.assign({}, Object.assign({ Component: EnhancedComponent, router }, props))));
        const render = staticMarkup ? server_1.renderToStaticMarkup : server_1.renderToString;
        let html;
        let head;
        try {
            if (err && dev) {
                const ErrorDebug = require(path_1.join(distDir, constants_1.SERVER_DIRECTORY, 'error-debug')).default;
                html = render(react_1.default.createElement(ErrorDebug, { error: err }));
            }
            else {
                html = render(app);
            }
        }
        finally {
            head = head_1.default.rewind() || head_1.defaultHead();
        }
        return { html, head, buildManifest };
    };
    await loadable_1.default.preloadAll(); // Make sure all dynamic imports are loaded
    const docProps = await utils_1.loadGetInitialProps(Document, Object.assign({}, ctx, { renderPage }));
    const dynamicImports = [...(new Set(getDynamicImportBundles(reactLoadableManifest, reactLoadableModules)))];
    const dynamicImportsIds = dynamicImports.map((bundle) => bundle.id);
    if (utils_1.isResSent(res))
        return;
    if (!Document.prototype || !Document.prototype.isReactComponent)
        throw new Error('_document.js is not exporting a React component');
    const doc = react_1.default.createElement(Document, Object.assign({}, Object.assign({ __NEXT_DATA__: {
            props,
            page,
            query,
            buildId,
            assetPrefix: assetPrefix === '' ? undefined : assetPrefix,
            runtimeConfig,
            nextExport,
            dynamicIds: dynamicImportsIds.length === 0 ? undefined : dynamicImportsIds,
            err: (err) ? serializeError(dev, err) : undefined // Error if one happened, otherwise don't sent in the resulting HTML
        }, dev,
        dir,
        staticMarkup,
        buildManifest,
        devFiles,
        files,
        dynamicImports,
        assetPrefix }, docProps)));
    return '<!DOCTYPE html>' + server_1.renderToStaticMarkup(doc);
}
async function renderScriptError(req, res, page, error) {
    // Asks CDNs and others to not to cache the errored page
    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');
    if (error.code === 'ENOENT' || error.message === 'INVALID_BUILD_ID') {
        res.statusCode = 404;
        res.end('404 - Not Found');
        return;
    }
    console.error(error.stack);
    res.statusCode = 500;
    res.end('500 - Internal Error');
}
exports.renderScriptError = renderScriptError;
function sendHTML(req, res, html, method, { dev, generateEtags }) {
    if (utils_1.isResSent(res))
        return;
    const etag = generateEtags && etag_1.default(html);
    if (fresh_1.default(req.headers, { etag })) {
        res.statusCode = 304;
        res.end();
        return;
    }
    if (dev) {
        // In dev, we should not cache pages for any reason.
        // That's why we do this.
        res.setHeader('Cache-Control', 'no-store, must-revalidate');
    }
    if (etag) {
        res.setHeader('ETag', etag);
    }
    if (!res.getHeader('Content-Type')) {
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
    }
    res.setHeader('Content-Length', Buffer.byteLength(html));
    res.end(method === 'HEAD' ? null : html);
}
exports.sendHTML = sendHTML;
function errorToJSON(err) {
    const { name, message, stack } = err;
    const json = { name, message, stack };
    if (err.module) {
        // rawRequest contains the filename of the module which has the error.
        const { rawRequest } = err.module;
        json.module = { rawRequest };
    }
    return json;
}
function serializeError(dev, err) {
    if (dev) {
        return errorToJSON(err);
    }
    return { message: '500 - Internal Server Error.' };
}
function serveStatic(req, res, path) {
    return new Promise((resolve, reject) => {
        send_1.default(req, path)
            .on('directory', () => {
            // We don't allow directories to be read.
            const err = new Error('No directory access');
            err.code = 'ENOENT';
            reject(err);
        })
            .on('error', reject)
            .pipe(res)
            .on('finish', resolve);
    });
}
exports.serveStatic = serveStatic;
