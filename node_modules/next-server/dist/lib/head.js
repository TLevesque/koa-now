"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const side_effect_1 = __importDefault(require("./side-effect"));
class Head extends react_1.default.Component {
    render() {
        return null;
    }
}
Head.contextTypes = {
    headManager: prop_types_1.default.object
};
const NEXT_HEAD_IDENTIFIER = 'next-head';
function defaultHead(className = NEXT_HEAD_IDENTIFIER) {
    return [
        react_1.default.createElement("meta", { key: 'charSet', charSet: 'utf-8', className: className })
    ];
}
exports.defaultHead = defaultHead;
function reduceComponents(components) {
    return components
        .map((component) => react_1.default.Children.toArray(component.props.children))
        .reduce((a, b) => a.concat(b), [])
        .reduce((a, b) => {
        if (react_1.default.Fragment && b.type === react_1.default.Fragment) {
            return a.concat(react_1.default.Children.toArray(b.props.children));
        }
        return a.concat(b);
    }, [])
        .reverse()
        .concat(defaultHead(''))
        .filter(Boolean)
        .filter(unique())
        .reverse()
        .map((c, i) => {
        const className = (c.props && c.props.className ? c.props.className + ' ' : '') + NEXT_HEAD_IDENTIFIER;
        const key = c.key || i;
        return react_1.default.cloneElement(c, { key, className });
    });
}
function mapOnServer(head) {
    return head;
}
function onStateChange(head) {
    if (this.context && this.context.headManager) {
        this.context.headManager.updateHead(head);
    }
}
const METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp', 'property'];
const ALLOWED_DUPLICATES = ['article:tag', 'og:image', 'og:image:alt', 'og:image:width', 'og:image:height', 'og:image:type', 'og:image:secure_url', 'og:image:url'];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>,
 except we explicit allow it in ALLOWED_DUPLICATES array
*/
function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h) => {
        if (h.key && h.key.indexOf('.$') === 0) {
            if (keys.has(h.key))
                return false;
            keys.add(h.key);
        }
        switch (h.type) {
            case 'title':
            case 'base':
                if (tags.has(h.type))
                    return false;
                tags.add(h.type);
                break;
            case 'meta':
                for (let i = 0, len = METATYPES.length; i < len; i++) {
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype))
                        continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype))
                            return false;
                        metaTypes.add(metatype);
                    }
                    else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if (categories.has(category) && ALLOWED_DUPLICATES.indexOf(category) === -1)
                            return false;
                        categories.add(category);
                        metaCategories[metatype] = categories;
                    }
                }
                break;
        }
        return true;
    };
}
if (process.env.NODE_ENV === 'development') {
    const exact = require('prop-types-exact');
    Head.propTypes = exact({
        children: prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.arrayOf(prop_types_1.default.element)]).isRequired
    });
}
exports.default = side_effect_1.default(reduceComponents, onStateChange, mapOnServer)(Head);
